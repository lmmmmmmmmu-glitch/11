<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>纯前端匿名聊天+语音通话（无服务器）</title>
    <style>
        * {margin: 0; padding: 0; box-sizing: border-box; font-family: "Microsoft YaHei", Arial, sans-serif;}
        body {max-width: 750px; margin: 15px auto; padding: 0 10px; background: #f0f2f5;}
        .container {background: #fff; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); padding: 20px;}
        .header {text-align: center; margin-bottom: 25px;}
        .header h2 {color: #333; margin-bottom: 15px; font-size: 20px;}
        .room-box {display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; justify-content: center;}
        .room-box input {flex: 1; min-width: 200px; padding: 12px 15px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 14px;}
        .room-box button {padding: 12px 20px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;}
        #createRoom {background: #165DFF; color: #fff;}
        #joinRoom {background: #36D399; color: #fff;}
        .info {color: #666; font-size: 13px; margin: 10px 0;}
        .user-id {color: #165DFF; font-weight: 600;}
        .chat-box {height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; padding: 15px; overflow-y: auto; margin-bottom: 20px; background: #f9fafb;}
        .msg {margin: 10px 0; padding: 10px 15px; border-radius: 10px; max-width: 75%; font-size: 14px; line-height: 1.5;}
        .my-msg {background: #165DFF; color: #fff; margin-left: auto;}
        .other-msg {background: #e5e7eb; color: #333; margin-right: auto;}
        .msg-header {font-size: 12px; opacity: 0.8; margin-bottom: 3px;}
        .input-area {display: flex; gap: 10px; align-items: center;}
        .input-area input {flex: 1; padding: 12px 15px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 14px;}
        .btn-group {display: flex; gap: 8px;}
        .btn-group button {padding: 12px 18px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;}
        #sendMsg {background: #165DFF; color: #fff;}
        #callBtn {background: #FB923C; color: #fff;}
        #hangupBtn {background: #EF4444; color: #fff; display: none;}
        .status {margin-top: 10px; font-size: 13px; color: #666;}
        .online {color: #36D399; font-weight: 600;}
        .offline {color: #EF4444; font-weight: 600;}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h2>纯前端匿名聊天+语音通话</h2>
            <div class="room-box">
                <input type="text" id="roomCode" placeholder="输入房间码（6位），或点击创建">
                <button id="createRoom">创建房间</button>
                <button id="joinRoom">加入房间</button>
            </div>
            <div class="info">你的匿名ID：<span class="user-id" id="userId"></span></div>
            <div class="info">房间状态：<span id="roomStatus" class="offline">未连接</span></div>
        </div>

        <div class="chat-box" id="chatBox"></div>

        <div class="input-area">
            <input type="text" id="msgInput" placeholder="输入消息，回车发送">
            <div class="btn-group">
                <button id="sendMsg">发送</button>
                <button id="callBtn">发起通话</button>
                <button id="hangupBtn">挂断通话</button>
            </div>
        </div>
        <div class="status" id="connStatus">请先创建/加入房间</div>
    </div>

    <script>
        // 全局变量
        let userId, roomCode;
        let peerConnection;
        let dataChannel; // 文字聊天数据通道
        let localStream, remoteStream;
        let isInitiator = false; // 是否为房间创建者

        // 生成随机6位字母数字房间码
        const generateRoomCode = () => Math.random().toString(36).slice(2, 8).toUpperCase();
        // 生成随机匿名ID
        const generateUserId = () => Math.random().toString(36).slice(2, 7);

        // WebRTC配置（公共STUN服务器，实现异地穿透）
        const RTC_CONFIG = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun.qq.com:3478' },
                { urls: 'stun:stun.cloudflare.com:3478' }
            ]
        };

        // 媒体配置（仅语音，关闭视频）
        const MEDIA_CONFIG = { audio: true, video: false };

        // 初始化页面
        window.onload = () => {
            userId = generateUserId();
            document.getElementById('userId').textContent = userId;
            bindEvents();
        };

        // 绑定页面事件
        const bindEvents = () => {
            // 创建房间
            document.getElementById('createRoom').addEventListener('click', () => {
                roomCode = generateRoomCode();
                document.getElementById('roomCode').value = roomCode;
                initPeerConnection(true);
                updateRoomStatus('创建中...');
            });

            // 加入房间
            document.getElementById('joinRoom').addEventListener('click', () => {
                roomCode = document.getElementById('roomCode').value.trim();
                if (!roomCode || roomCode.length !== 6) {
                    alert('请输入6位有效房间码！');
                    return;
                }
                initPeerConnection(false);
                updateRoomStatus('加入中...');
            });

            // 发送消息
            document.getElementById('sendMsg').addEventListener('click', sendMessage);
            document.getElementById('msgInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') sendMessage();
            });

            // 语音通话
            document.getElementById('callBtn').addEventListener('click', startCall);
            document.getElementById('hangupBtn').addEventListener('click', hangupCall);
        };

        // 初始化WebRTC点对点连接
        const initPeerConnection = (initiator) => {
            isInitiator = initiator;
            // 关闭原有连接
            if (peerConnection) peerConnection.close();

            // 创建新的RTCPeerConnection
            peerConnection = new RTCPeerConnection(RTC_CONFIG);
            updateConnStatus('正在建立点对点连接...');

            // 监听ICE候选者
            peerConnection.onicecandidate = (e) => {
                if (e.candidate) {
                    // 这里省略了信令服务器，实际异地匹配可通过「房间码+第三方临时信令」，此处简化为直接匹配（见备注）
                    updateConnStatus('正在穿透网络...');
                }
            };

            // 监听数据通道（文字聊天）
            peerConnection.ondatachannel = (e) => {
                dataChannel = e.channel;
                initDataChannel();
            };

            // 监听远程流（语音通话）
            peerConnection.ontrack = (e) => {
                remoteStream = e.streams[0];
                // 播放远程语音
                const audio = new Audio();
                audio.srcObject = remoteStream;
                audio.play().catch(err => console.log('语音播放失败：', err));
                updateConnStatus('已建立语音连接！');
            };

            // 监听连接状态
            peerConnection.onconnectionstatechange = () => {
                switch (peerConnection.connectionState) {
                    case 'connected':
                        updateRoomStatus('已连接', 'online');
                        updateConnStatus('点对点连接成功！可聊天/通话');
                        break;
                    case 'disconnected':
                        updateRoomStatus('已断开', 'offline');
                        updateConnStatus('连接已断开，请重新创建/加入房间');
                        hangupCall();
                        break;
                    case 'failed':
                        updateRoomStatus('连接失败', 'offline');
                        updateConnStatus('网络穿透失败，请检查网络或更换房间码');
                        break;
                }
            };

            // 房间创建者主动创建数据通道
            if (isInitiator) {
                dataChannel = peerConnection.createDataChannel('chatChannel', {
                    ordered: true, // 保证消息顺序
                    reliable: true
                });
                initDataChannel();
                createOffer();
            }
        };

        // 初始化数据通道（文字聊天）
        const initDataChannel = () => {
            // 数据通道打开
            dataChannel.onopen = () => {
                updateConnStatus('聊天通道已就绪，可发送消息');
            };

            // 接收消息
            dataChannel.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                addMessage(msg.sender, msg.content, 'other-msg');
            };

            // 数据通道关闭
            dataChannel.onclose = () => {
                updateConnStatus('聊天通道已关闭');
            };

            // 数据通道错误
            dataChannel.onerror = (err) => {
                console.error('数据通道错误：', err);
                updateConnStatus('聊天通道出错：' + err.message);
            };
        };

        // 创建Offer（房间创建者）
        const createOffer = async () => {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                updateConnStatus('已创建Offer，等待对方连接');
            } catch (err) {
                console.error('创建Offer失败：', err);
                updateConnStatus('创建连接失败：' + err.message);
            }
        };

        // 发送文字消息
        const sendMessage = () => {
            const content = document.getElementById('msgInput').value.trim();
            if (!content || !dataChannel || dataChannel.readyState !== 'open') {
                alert('请先建立聊天连接！');
                return;
            }

            // 构造消息对象
            const msg = {
                sender: userId,
                content: content,
                time: new Date().toLocaleTimeString()
            };

            // 发送到数据通道
            dataChannel.send(JSON.stringify(msg));
            // 添加到自己的聊天框
            addMessage('我', content, 'my-msg');
            // 清空输入框
            document.getElementById('msgInput').value = '';
        };

        // 添加消息到聊天框
        const addMessage = (sender, content, className) => {
            const chatBox = document.getElementById('chatBox');
            const time = new Date().toLocaleTimeString();
            const msgElement = document.createElement('div');
            msgElement.className = `msg ${className}`;
            msgElement.innerHTML = `
                <div class="msg-header">${sender} · ${time}</div>
                <div class="msg-content">${content}</div>
            `;
            chatBox.appendChild(msgElement);
            // 滚动到底部
            chatBox.scrollTop = chatBox.scrollHeight;
        };

        // 开始语音通话
        const startCall = async () => {
            if (!peerConnection || peerConnection.connectionState !== 'connected') {
                alert('请先建立点对点连接！');
                return;
            }

            try {
                // 获取本地麦克风流
                localStream = await navigator.mediaDevices.getUserMedia(MEDIA_CONFIG);
                // 将本地流添加到连接
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // 更新按钮状态
                document.getElementById('callBtn').style.display = 'none';
                document.getElementById('hangupBtn').style.display = 'inline-block';
                addMessage('系统', '已发起语音通话，对方可接听', 'my-msg');
                updateConnStatus('语音通话中...');
            } catch (err) {
                alert('获取麦克风权限失败：' + err.message);
                console.error('麦克风权限错误：', err);
            }
        };

        // 挂断通话
        const hangupCall = () => {
            // 停止本地流
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            // 关闭远程流播放
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }

            // 更新按钮状态
            document.getElementById('callBtn').style.display = 'inline-block';
            document.getElementById('hangupBtn').style.display = 'none';

            if (peerConnection) {
                addMessage('系统', '已挂断语音通话', 'my-msg');
                updateConnStatus('已挂断通话，可继续聊天');
            }
        };

        // 更新房间状态
        const updateRoomStatus = (text, className = 'offline') => {
            const status = document.getElementById('roomStatus');
            status.textContent = text;
            status.className = className;
        };

        // 更新连接状态
        const updateConnStatus = (text) => {
            document.getElementById('connStatus').textContent = text;
        };

        // 页面关闭时清理资源
        window.onbeforeunload = () => {
            if (peerConnection) peerConnection.close();
            if (localStream) localStream.getTracks().forEach(track => track.stop());
        };
    </script>
</body>
</html>
